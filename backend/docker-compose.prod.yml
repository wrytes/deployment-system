services:
    postgres:
        image: postgres:16-alpine
        container_name: deployment_platform_postgres
        environment:
            POSTGRES_USER: ${POSTGRES_USER:-postgres}
            POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
            POSTGRES_DB: ${POSTGRES_DB:-deployment_system}
        volumes:
            - postgres_data:/var/lib/postgresql/data
        networks:
            - backend
        healthcheck:
            test: ['CMD-SHELL', 'pg_isready -U ${POSTGRES_USER:-postgres}']
            interval: 10s
            timeout: 5s
            retries: 5
        restart: always
        deploy:
            resources:
                limits:
                    cpus: '1'
                    memory: 1G

    redis:
        image: redis:7-alpine
        container_name: deployment_platform_redis
        command: redis-server --requirepass ${REDIS_PASSWORD}
        volumes:
            - redis_data:/data
        networks:
            - backend
        healthcheck:
            test: ['CMD', 'redis-cli', 'ping']
            interval: 10s
            timeout: 3s
            retries: 5
        restart: always
        deploy:
            resources:
                limits:
                    cpus: '0.5'
                    memory: 512M

    backend:
        build:
            context: .
            dockerfile: Dockerfile
        container_name: deployment_platform_backend
        # Run as root to access Docker socket for managing containers
        user: root
        env_file:
            - .env
        volumes:
            - /var/run/docker.sock:/var/run/docker.sock
        networks:
            - backend
        depends_on:
            postgres:
                condition: service_healthy
            redis:
                condition: service_healthy
            letsencrypt:
                condition: service_started
        healthcheck:
            test:
                [
                    'CMD',
                    'node',
                    '-e',
                    "require('http').get('http://localhost:3000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})",
                ]
            interval: 30s
            timeout: 10s
            retries: 3
            start_period: 40s
        restart: always
        deploy:
            resources:
                limits:
                    cpus: '2'
                    memory: 2G

    nginx-proxy:
        image: bbtsoftwareag/nginx-proxy-unrestricted-requestsize:alpine
        container_name: nginx_proxy
        labels:
            - 'com.github.jrcs.letsencrypt_nginx_proxy_companion.nginx_proxy'
        volumes:
            - nginx-vhost-vol:/etc/nginx/vhost.d
            - nginx-share-vol:/usr/share/nginx/html
            - nginx-certs-vol:/etc/nginx/certs
            - acme:/etc/acme.sh
            - /var/run/docker.sock:/tmp/docker.sock:ro
        ports:
            - target: 80
              published: 80
              mode: host
            - target: 443
              published: 443
              mode: host
        networks:
            - backend
        restart: always
        # Note: Will dynamically attach to each environment's overlay network when made public

    letsencrypt:
        image: jrcs/letsencrypt-nginx-proxy-companion:2.2
        container_name: letsencrypt_companion
        depends_on:
            - nginx-proxy
        volumes:
            - nginx-vhost-vol:/etc/nginx/vhost.d
            - nginx-share-vol:/usr/share/nginx/html
            - nginx-certs-vol:/etc/nginx/certs
            - acme:/etc/acme.sh
            - /var/run/docker.sock:/var/run/docker.sock:ro
        environment:
            - DEFAULT_EMAIL=${LETSENCRYPT_EMAIL}
        networks:
            - backend
        restart: always

volumes:
    postgres_data:
        driver: local
    redis_data:
        driver: local
    nginx-vhost-vol:
        driver: local
    nginx-share-vol:
        driver: local
    nginx-certs-vol:
        driver: local
    acme:
        driver: local

networks:
    backend:
        driver: bridge
    # Per-environment overlay networks created dynamically
